/**
 * Contract test for SubtitleService
 * Tests the service interface for subtitle operations
 */

import {
  ISubtitleService,
  SubtitleInfo,
  SubtitleGenerationOptions,
  EmbedSubtitleOptions
} from '../../../specs/001-youtube-youtube/contracts/service-interfaces';

describe('Service Contract: SubtitleService', () => {
  let mockSubtitleService: ISubtitleService;

  beforeEach(() => {
    mockSubtitleService = {
      listAvailableSubtitles: jest.fn(),
      downloadSubtitle: jest.fn(),
      generateSubtitle: jest.fn(),
      embedSubtitles: jest.fn(),
      convertFormat: jest.fn()
    };
  });

  describe('listAvailableSubtitles()', () => {
    it('should list available subtitles for video', async () => {
      const mockSubtitles: SubtitleInfo[] = [
        {
          language: 'en',
          languageName: 'English',
          isAutoGenerated: false,
          formats: ['vtt', 'srt', 'json']
        },
        {
          language: 'zh-CN',
          languageName: '中文(简体)',
          isAutoGenerated: false,
          formats: ['vtt', 'srt']
        },
        {
          language: 'ja',
          languageName: '日本語',
          isAutoGenerated: true,
          formats: ['vtt']
        }
      ];

      (mockSubtitleService.listAvailableSubtitles as jest.Mock).mockResolvedValue(mockSubtitles);

      const result = await mockSubtitleService.listAvailableSubtitles('https://www.youtube.com/watch?v=test');

      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBeGreaterThan(0);

      result.forEach(subtitle => {
        expect(subtitle).toHaveProperty('language');
        expect(subtitle).toHaveProperty('languageName');
        expect(subtitle).toHaveProperty('isAutoGenerated');
        expect(subtitle).toHaveProperty('formats');
        expect(Array.isArray(subtitle.formats)).toBe(true);
      });
    });

    it('should handle videos with no subtitles', async () => {
      (mockSubtitleService.listAvailableSubtitles as jest.Mock).mockResolvedValue([]);

      const result = await mockSubtitleService.listAvailableSubtitles('https://youtube.com/watch?v=no-subs');

      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBe(0);
    });
  });

  describe('downloadSubtitle()', () => {
    it('should download subtitle in specified language', async () => {
      const mockSubtitle = {
        id: 'sub-001',
        videoId: 'test-video',
        language: 'en',
        languageName: 'English',
        format: 'srt' as const,
        content: `1
00:00:00,000 --> 00:00:05,000
Hello World

2
00:00:05,000 --> 00:00:10,000
This is a test subtitle`,
        isAutoGenerated: false,
        timestamps: [
          { startTime: 0, endTime: 5000, text: 'Hello World' },
          { startTime: 5000, endTime: 10000, text: 'This is a test subtitle' }
        ]
      };

      (mockSubtitleService.downloadSubtitle as jest.Mock).mockResolvedValue(mockSubtitle);

      const result = await mockSubtitleService.downloadSubtitle(
        'https://www.youtube.com/watch?v=test',
        'en'
      );

      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('language');
      expect(result).toHaveProperty('content');
      expect(result).toHaveProperty('format');
      expect(result.language).toBe('en');
      expect(result.content.length).toBeGreaterThan(0);
    });

    it('should handle unavailable language', async () => {
      (mockSubtitleService.downloadSubtitle as jest.Mock).mockRejectedValue(
        new Error('Subtitle not available in requested language')
      );

      await expect(
        mockSubtitleService.downloadSubtitle('https://youtube.com/watch?v=test', 'xx')
      ).rejects.toThrow('Subtitle not available');
    });
  });

  describe('generateSubtitle()', () => {
    it('should generate subtitle using Whisper', async () => {
      const options: SubtitleGenerationOptions = {
        language: 'en',
        model: 'base',
        translate: false,
        detectLanguage: false
      };

      const mockGeneratedSubtitle = {
        id: 'gen-001',
        videoId: 'local-video',
        language: 'en',
        languageName: 'English',
        format: 'srt' as const,
        content: 'Generated subtitle content...',
        isAutoGenerated: true,
        timestamps: []
      };

      (mockSubtitleService.generateSubtitle as jest.Mock).mockResolvedValue(mockGeneratedSubtitle);

      const result = await mockSubtitleService.generateSubtitle('/path/to/video.mp4', options);

      expect(result).toHaveProperty('isAutoGenerated');
      expect(result.isAutoGenerated).toBe(true);
      expect(result.language).toBe('en');
    });

    it('should support different Whisper models', async () => {
      const models: Array<SubtitleGenerationOptions['model']> = [
        'tiny',
        'base',
        'small',
        'medium',
        'large'
      ];

      for (const model of models) {
        const options: SubtitleGenerationOptions = {
          model,
          language: 'en'
        };

        (mockSubtitleService.generateSubtitle as jest.Mock).mockResolvedValue({
          id: `gen-${model}`,
          language: 'en',
          isAutoGenerated: true
        });

        const result = await mockSubtitleService.generateSubtitle('/video.mp4', options);
        expect(result).toBeDefined();
      }
    });

    it('should support language detection', async () => {
      const options: SubtitleGenerationOptions = {
        detectLanguage: true,
        model: 'base'
      };

      (mockSubtitleService.generateSubtitle as jest.Mock).mockResolvedValue({
        id: 'gen-detect',
        language: 'zh', // Detected Chinese
        languageName: '中文',
        isAutoGenerated: true
      });

      const result = await mockSubtitleService.generateSubtitle('/chinese-video.mp4', options);
      expect(result.language).toBe('zh');
    });

    it('should support translation', async () => {
      const options: SubtitleGenerationOptions = {
        language: 'en',
        translate: true, // Translate to English
        model: 'base'
      };

      (mockSubtitleService.generateSubtitle as jest.Mock).mockResolvedValue({
        id: 'gen-translate',
        language: 'en',
        languageName: 'English (Translated)',
        isAutoGenerated: true
      });

      const result = await mockSubtitleService.generateSubtitle('/foreign-video.mp4', options);
      expect(result.language).toBe('en');
    });
  });

  describe('embedSubtitles()', () => {
    it('should embed single subtitle', async () => {
      const mockSubtitle = {
        id: 'sub-001',
        language: 'en',
        format: 'srt' as const,
        content: 'Subtitle content...'
      };

      const options: EmbedSubtitleOptions = {
        primarySubtitle: mockSubtitle as any,
        layout: 'stacked',
        outputPath: '/output/video-with-subs.mp4'
      };

      const mockTask = {
        id: 'embed-001',
        type: 'SUBTITLE_EMBEDDING',
        status: 'completed',
        outputFile: '/output/video-with-subs.mp4'
      };

      (mockSubtitleService.embedSubtitles as jest.Mock).mockResolvedValue(mockTask);

      const result = await mockSubtitleService.embedSubtitles('/video.mp4', options);

      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('status');
      expect(result).toHaveProperty('outputFile');
    });

    it('should embed bilingual subtitles', async () => {
      const primarySubtitle = {
        id: 'sub-zh',
        language: 'zh-CN',
        format: 'srt' as const,
        content: 'Chinese subtitle...'
      };

      const secondarySubtitle = {
        id: 'sub-en',
        language: 'en',
        format: 'srt' as const,
        content: 'English subtitle...'
      };

      const options: EmbedSubtitleOptions = {
        primarySubtitle: primarySubtitle as any,
        secondarySubtitle: secondarySubtitle as any,
        layout: 'stacked',
        styling: {
          primaryFontSize: 24,
          secondaryFontSize: 20,
          primaryColor: '#FFFFFF',
          secondaryColor: '#FFFF00',
          fontFamily: 'Arial',
          outline: true,
          shadow: true
        },
        outputPath: '/output/bilingual.mp4'
      };

      const mockTask = {
        id: 'embed-bilingual',
        type: 'SUBTITLE_EMBEDDING',
        status: 'completed',
        outputFile: '/output/bilingual.mp4'
      };

      (mockSubtitleService.embedSubtitles as jest.Mock).mockResolvedValue(mockTask);

      const result = await mockSubtitleService.embedSubtitles('/video.mp4', options);

      expect(result).toBeDefined();
      expect(result.outputFile).toBe('/output/bilingual.mp4');
    });

    it('should validate layout options', () => {
      const layouts: Array<EmbedSubtitleOptions['layout']> = ['stacked', 'side_by_side'];

      layouts.forEach(layout => {
        const options: EmbedSubtitleOptions = {
          primarySubtitle: {} as any,
          layout,
          outputPath: '/output.mp4'
        };

        expect(layouts).toContain(options.layout);
      });
    });
  });

  describe('convertFormat()', () => {
    it('should convert subtitle format', async () => {
      const inputSubtitle = {
        id: 'sub-001',
        language: 'en',
        format: 'vtt' as const,
        content: 'WEBVTT\n\n00:00:00.000 --> 00:00:05.000\nHello World'
      };

      const expectedOutput = {
        ...inputSubtitle,
        format: 'srt' as const,
        content: '1\n00:00:00,000 --> 00:00:05,000\nHello World'
      };

      (mockSubtitleService.convertFormat as jest.Mock).mockResolvedValue(expectedOutput);

      const result = await mockSubtitleService.convertFormat(inputSubtitle as any, 'srt');

      expect(result.format).toBe('srt');
      expect(result.content).toContain('-->');
    });

    it('should support multiple format conversions', async () => {
      const formats: Array<'srt' | 'vtt' | 'ass'> = ['srt', 'vtt', 'ass'];

      for (const targetFormat of formats) {
        const inputSubtitle = {
          id: 'sub-001',
          format: 'srt' as const,
          content: 'Original content'
        };

        (mockSubtitleService.convertFormat as jest.Mock).mockResolvedValue({
          ...inputSubtitle,
          format: targetFormat
        });

        const result = await mockSubtitleService.convertFormat(inputSubtitle as any, targetFormat);
        expect(result.format).toBe(targetFormat);
      }
    });

    it('should handle invalid format conversion', async () => {
      (mockSubtitleService.convertFormat as jest.Mock).mockRejectedValue(
        new Error('Unsupported format conversion')
      );

      const subtitle = { format: 'xyz', content: 'content' };

      await expect(
        mockSubtitleService.convertFormat(subtitle as any, 'srt')
      ).rejects.toThrow('Unsupported format');
    });
  });

  describe('Error Handling', () => {
    it('should handle file not found', async () => {
      (mockSubtitleService.generateSubtitle as jest.Mock).mockRejectedValue(
        new Error('Video file not found')
      );

      await expect(
        mockSubtitleService.generateSubtitle('/non-existent.mp4', { model: 'base' })
      ).rejects.toThrow('Video file not found');
    });

    it('should handle Whisper model loading error', async () => {
      (mockSubtitleService.generateSubtitle as jest.Mock).mockRejectedValue(
        new Error('Failed to load Whisper model')
      );

      await expect(
        mockSubtitleService.generateSubtitle('/video.mp4', { model: 'large' })
      ).rejects.toThrow('Failed to load Whisper model');
    });

    it('should handle subtitle sync issues', async () => {
      (mockSubtitleService.embedSubtitles as jest.Mock).mockRejectedValue(
        new Error('Subtitle timing does not match video duration')
      );

      await expect(
        mockSubtitleService.embedSubtitles('/video.mp4', {
          primarySubtitle: {} as any,
          layout: 'stacked',
          outputPath: '/output.mp4'
        })
      ).rejects.toThrow('Subtitle timing');
    });
  });
});