/**
 * SubtitleService - Handles subtitle operations using Whisper and ffmpeg
 */

import { spawn, ChildProcess } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import { EventEmitter } from 'events';
import {
  Subtitle,
  SubtitleInfo,
  SubtitleGenerationOptions,
  EmbedSubtitleOptions,
  SubtitleTimestamp
} from '../../shared/types/subtitle';
import { ProcessingTask } from '../../shared/types/tasks';
import { ISubtitleService } from '../../../specs/001-youtube-youtube/contracts/service-interfaces';

export class SubtitleService extends EventEmitter implements ISubtitleService {
  private whisperPath: string;
  private ffmpegPath: string;
  private ytdlpPath: string;
  private tasks: Map<string, ProcessingTask> = new Map();
  private processes: Map<string, ChildProcess> = new Map();

  constructor(whisperPath?: string, ffmpegPath?: string, ytdlpPath?: string) {
    super();
    this.whisperPath = whisperPath || this.getWhisperPath();
    this.ffmpegPath = ffmpegPath || this.getFfmpegPath();
    this.ytdlpPath = ytdlpPath || this.getYtdlpPath();
  }

  private getWhisperPath(): string {
    const possiblePaths = [
      path.join(__dirname, '../../../binaries/whisper'),
      path.join(process.resourcesPath, 'binaries/whisper'),
      'whisper'
    ];

    for (const p of possiblePaths) {
      if (fs.existsSync(p)) {
        return p;
      }
    }
    return 'whisper';
  }

  private getFfmpegPath(): string {
    const possiblePaths = [
      path.join(__dirname, '../../../binaries/ffmpeg'),
      path.join(process.resourcesPath, 'binaries/ffmpeg'),
      'ffmpeg'
    ];

    for (const p of possiblePaths) {
      if (fs.existsSync(p)) {
        return p;
      }
    }
    return 'ffmpeg';
  }

  private getYtdlpPath(): string {
    const possiblePaths = [
      path.join(__dirname, '../../../binaries/yt-dlp'),
      path.join(process.resourcesPath, 'binaries/yt-dlp'),
      'yt-dlp'
    ];

    for (const p of possiblePaths) {
      if (fs.existsSync(p)) {
        return p;
      }
    }
    return 'yt-dlp';
  }

  async listAvailableSubtitles(videoUrl: string): Promise<SubtitleInfo[]> {
    return new Promise((resolve, reject) => {
      const args = [
        videoUrl,
        '--list-subs',
        '--no-warnings'
      ];

      const process = spawn(this.ytdlpPath, args);
      let output = '';
      let errorOutput = '';

      process.stdout.on('data', (data) => {
        output += data.toString();
      });

      process.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      process.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`Failed to list subtitles: ${errorOutput}`));
          return;
        }

        const subtitles = this.parseSubtitleList(output);
        resolve(subtitles);
      });

      process.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error}`));
      });
    });
  }

  private parseSubtitleList(output: string): SubtitleInfo[] {
    const subtitles: SubtitleInfo[] = [];
    const lines = output.split('\n');
    let inSubtitleSection = false;

    for (const line of lines) {
      if (line.includes('Available subtitles') || line.includes('Available automatic captions')) {
        inSubtitleSection = true;
        continue;
      }

      if (inSubtitleSection && line.trim()) {
        const match = line.match(/^(\w+(?:-\w+)?)\s+(\w+(?:\s+\w+)*)/);
        if (match) {
          const [, language, name] = match;
          const isAuto = output.includes('automatic captions') && lines.indexOf(line) > output.indexOf('automatic captions');

          subtitles.push({
            language,
            languageName: name.trim(),
            isAutoGenerated: isAuto,
            formats: ['vtt', 'srt', 'json']
          });
        }
      }
    }

    return subtitles;
  }

  async downloadSubtitle(videoUrl: string, language: string, format: 'srt' | 'vtt' | 'ass' = 'srt'): Promise<Subtitle> {
    const subtitleId = this.generateSubtitleId();
    const outputPath = path.join('/tmp', `subtitle-${subtitleId}.${format}`);

    return new Promise((resolve, reject) => {
      const args = [
        videoUrl,
        '--write-sub',
        '--sub-lang', language,
        '--sub-format', format,
        '--skip-download',
        '-o', outputPath.replace(`.${format}`, ''),
        '--no-warnings'
      ];

      const process = spawn(this.ytdlpPath, args);
      let errorOutput = '';

      process.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      process.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`Failed to download subtitle: ${errorOutput}`));
          return;
        }

        const subtitleFile = `${outputPath.replace(`.${format}`, '')}.${language}.${format}`;
        if (!fs.existsSync(subtitleFile)) {
          reject(new Error('Subtitle file not found after download'));
          return;
        }

        const content = fs.readFileSync(subtitleFile, 'utf-8');
        const timestamps = this.parseSubtitleContent(content, format);

        const subtitle: Subtitle = {
          id: subtitleId,
          videoId: this.extractVideoId(videoUrl),
          language,
          languageName: this.getLanguageName(language),
          format,
          content,
          isAutoGenerated: false,
          timestamps
        };

        // Clean up temp file
        fs.unlinkSync(subtitleFile);

        resolve(subtitle);
      });

      process.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error}`));
      });
    });
  }

  async generateSubtitle(videoPath: string, options: SubtitleGenerationOptions): Promise<Subtitle> {
    const taskId = this.generateTaskId();
    const subtitleId = this.generateSubtitleId();
    const outputFormat = options.outputFormat || 'srt';
    const outputPath = path.join('/tmp', `generated-${subtitleId}.${outputFormat}`);

    const task: ProcessingTask = {
      id: taskId,
      type: 'SUBTITLE_GENERATION',
      status: 'downloading',
      progress: 0,
      inputFile: videoPath,
      outputFile: outputPath,
      config: options,
      startTime: new Date()
    };

    this.tasks.set(taskId, task);

    return new Promise((resolve, reject) => {
      const args = this.buildWhisperArgs(videoPath, outputPath, options);
      const process = spawn(this.whisperPath, args);
      this.processes.set(taskId, process);

      let output = '';
      let errorOutput = '';

      process.stdout.on('data', (data) => {
        output += data.toString();
        this.parseWhisperProgress(data.toString(), taskId);
      });

      process.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      process.on('close', (code) => {
        this.processes.delete(taskId);
        task.status = code === 0 ? 'completed' : 'failed';
        task.endTime = new Date();

        if (code !== 0) {
          task.error = errorOutput;
          reject(new Error(`Whisper failed: ${errorOutput}`));
          return;
        }

        if (!fs.existsSync(outputPath)) {
          reject(new Error('Generated subtitle file not found'));
          return;
        }

        const content = fs.readFileSync(outputPath, 'utf-8');
        const timestamps = this.parseSubtitleContent(content, outputFormat);

        const subtitle: Subtitle = {
          id: subtitleId,
          videoId: path.basename(videoPath, path.extname(videoPath)),
          language: options.language || 'auto',
          languageName: options.translate ? 'English (Translated)' : this.getLanguageName(options.language || 'auto'),
          format: outputFormat,
          content,
          isAutoGenerated: true,
          timestamps
        };

        // Clean up temp file
        fs.unlinkSync(outputPath);

        resolve(subtitle);
      });

      process.on('error', (error) => {
        this.processes.delete(taskId);
        task.status = 'failed';
        task.error = error.message;
        reject(new Error(`Failed to spawn whisper: ${error}`));
      });
    });
  }

  private buildWhisperArgs(videoPath: string, outputPath: string, options: SubtitleGenerationOptions): string[] {
    const args = [
      videoPath,
      '--output', outputPath
    ];

    if (options.model) {
      args.push('--model', options.model);
    }

    if (options.language) {
      args.push('--language', options.language);
    }

    if (options.translate) {
      args.push('--task', 'translate');
    } else if (options.task) {
      args.push('--task', options.task);
    }

    if (options.outputFormat) {
      args.push('--output-format', options.outputFormat);
    }

    return args;
  }

  private parseWhisperProgress(output: string, taskId: string): void {
    const task = this.tasks.get(taskId);
    if (!task) return;

    // Parse Whisper progress
    const progressMatch = output.match(/(\d+)%\|/);
    if (progressMatch) {
      task.progress = parseInt(progressMatch[1]);
      this.emit('subtitle-progress', taskId, task);
    }
  }

  async embedSubtitles(videoPath: string, options: EmbedSubtitleOptions): Promise<ProcessingTask> {
    const taskId = this.generateTaskId();
    const outputPath = options.outputPath;

    const task: ProcessingTask = {
      id: taskId,
      type: 'SUBTITLE_EMBEDDING',
      status: 'downloading',
      progress: 0,
      inputFile: videoPath,
      outputFile: outputPath,
      config: options,
      startTime: new Date()
    };

    this.tasks.set(taskId, task);

    return new Promise((resolve, reject) => {
      const args = this.buildFfmpegEmbedArgs(videoPath, outputPath, options);
      const process = spawn(this.ffmpegPath, args);
      this.processes.set(taskId, process);

      let errorOutput = '';

      process.stderr.on('data', (data) => {
        const output = data.toString();
        errorOutput += output;
        this.parseFfmpegProgress(output, taskId, videoPath);
      });

      process.on('close', (code) => {
        this.processes.delete(taskId);
        task.status = code === 0 ? 'completed' : 'failed';
        task.endTime = new Date();

        if (code !== 0) {
          task.error = errorOutput;
          reject(new Error(`FFmpeg failed: ${errorOutput}`));
          return;
        }

        resolve(task);
      });

      process.on('error', (error) => {
        this.processes.delete(taskId);
        task.status = 'failed';
        task.error = error.message;
        reject(new Error(`Failed to spawn ffmpeg: ${error}`));
      });
    });
  }

  private buildFfmpegEmbedArgs(videoPath: string, outputPath: string, options: EmbedSubtitleOptions): string[] {
    const args = [
      '-i', videoPath
    ];

    // Create temporary subtitle files
    const primarySubPath = path.join('/tmp', `primary-${Date.now()}.${options.primarySubtitle.format}`);
    fs.writeFileSync(primarySubPath, options.primarySubtitle.content);
    args.push('-i', primarySubPath);

    if (options.secondarySubtitle) {
      const secondarySubPath = path.join('/tmp', `secondary-${Date.now()}.${options.secondarySubtitle.format}`);
      fs.writeFileSync(secondarySubPath, options.secondarySubtitle.content);
      args.push('-i', secondarySubPath);
    }

    if (options.hardSub) {
      // Hard subtitle (burn into video)
      const filterComplex = this.buildSubtitleFilter(options);
      args.push('-vf', filterComplex);
    } else {
      // Soft subtitle (as separate stream)
      args.push('-c:v', 'copy');
      args.push('-c:a', 'copy');
      args.push('-c:s', 'mov_text');
    }

    args.push('-y'); // Overwrite output
    args.push(outputPath);

    return args;
  }

  private buildSubtitleFilter(options: EmbedSubtitleOptions): string {
    const styling = options.styling || {};
    let filter = '';

    if (options.layout === 'stacked') {
      // Stack subtitles vertically
      const primaryY = styling.primaryColor ? 'h-60' : 'h-50';
      const secondaryY = styling.secondaryColor ? 'h-30' : 'h-40';

      filter = `subtitles=filename='${options.primarySubtitle.content}':force_style='Fontsize=${styling.primaryFontSize || 24},PrimaryColour=${styling.primaryColor || '&HFFFFFF&'},Alignment=2,MarginV=10'`;

      if (options.secondarySubtitle) {
        filter += `,subtitles=filename='${options.secondarySubtitle.content}':force_style='Fontsize=${styling.secondaryFontSize || 20},PrimaryColour=${styling.secondaryColor || '&HFFFF00&'},Alignment=2,MarginV=40'`;
      }
    } else {
      // Side by side layout
      filter = `subtitles=filename='${options.primarySubtitle.content}'`;
      if (options.secondarySubtitle) {
        filter += `,subtitles=filename='${options.secondarySubtitle.content}'`;
      }
    }

    return filter;
  }

  private parseFfmpegProgress(output: string, taskId: string, videoPath: string): void {
    const task = this.tasks.get(taskId);
    if (!task) return;

    // Parse FFmpeg progress
    const timeMatch = output.match(/time=(\d{2}):(\d{2}):(\d{2})/);
    if (timeMatch) {
      const currentTime = parseInt(timeMatch[1]) * 3600 + parseInt(timeMatch[2]) * 60 + parseInt(timeMatch[3]);
      // Would need video duration to calculate percentage
      // For now, emit progress event
      this.emit('embed-progress', taskId, task);
    }
  }

  async convertFormat(subtitle: Subtitle, targetFormat: 'srt' | 'vtt' | 'ass'): Promise<Subtitle> {
    const convertedContent = this.convertSubtitleFormat(subtitle.content, subtitle.format, targetFormat);

    return {
      ...subtitle,
      format: targetFormat,
      content: convertedContent
    };
  }

  private convertSubtitleFormat(content: string, fromFormat: string, toFormat: string): string {
    // Simple conversion logic - in production, use a proper library
    if (fromFormat === toFormat) {
      return content;
    }

    if (fromFormat === 'vtt' && toFormat === 'srt') {
      return this.vttToSrt(content);
    }

    if (fromFormat === 'srt' && toFormat === 'vtt') {
      return this.srtToVtt(content);
    }

    // For other conversions, return as-is (would need proper implementation)
    return content;
  }

  private vttToSrt(vttContent: string): string {
    let srtContent = vttContent.replace('WEBVTT\n\n', '');
    srtContent = srtContent.replace(/(\d{2}):(\d{2}):(\d{2})\.(\d{3})/g, '$1:$2:$3,$4');

    // Add subtitle numbers
    const lines = srtContent.split('\n\n');
    return lines.map((block, index) => `${index + 1}\n${block}`).join('\n\n');
  }

  private srtToVtt(srtContent: string): string {
    let vttContent = 'WEBVTT\n\n';
    vttContent += srtContent.replace(/(\d{2}):(\d{2}):(\d{2}),(\d{3})/g, '$1:$2:$3.$4');

    // Remove subtitle numbers
    vttContent = vttContent.replace(/^\d+\n/gm, '');

    return vttContent;
  }

  private parseSubtitleContent(content: string, format: string): SubtitleTimestamp[] {
    const timestamps: SubtitleTimestamp[] = [];

    if (format === 'srt') {
      const blocks = content.split('\n\n');
      for (const block of blocks) {
        const lines = block.split('\n');
        if (lines.length >= 3) {
          const timeMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
          if (timeMatch) {
            const startTime = this.timeToMs(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
            const endTime = this.timeToMs(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
            const text = lines.slice(2).join('\n');
            timestamps.push({ startTime, endTime, text });
          }
        }
      }
    }

    return timestamps;
  }

  private timeToMs(hours: string, minutes: string, seconds: string, ms: string): number {
    return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(ms);
  }

  private extractVideoId(url: string): string {
    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
    return match ? match[1] : 'unknown';
  }

  private getLanguageName(code: string): string {
    const languages: { [key: string]: string } = {
      'en': 'English',
      'zh-CN': '中文(简体)',
      'zh-TW': '中文(繁體)',
      'ja': '日本語',
      'ko': '한국어',
      'es': 'Español',
      'fr': 'Français',
      'de': 'Deutsch',
      'ru': 'Русский',
      'pt': 'Português',
      'it': 'Italiano',
      'auto': 'Auto-detect'
    };

    return languages[code] || code;
  }

  private generateSubtitleId(): string {
    return `subtitle-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateTaskId(): string {
    return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}